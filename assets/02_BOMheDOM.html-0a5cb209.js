import{_ as s,o as n,c as l,e}from"./app-68bdc183.js";const t="/myblogs/assets/01.f63fd3ed-8b2c3047.png",a="/myblogs/assets/02.0e6380e2-0bda7a57.png",i="/myblogs/assets/09.c22ce283-8bd12c02.png",o={},c=e('<h2 id="dom介绍" tabindex="-1"><a class="header-anchor" href="#dom介绍" aria-hidden="true">#</a> DOM介绍</h2><blockquote><p>现在已基本不直接操作DOM,简单了解即可</p></blockquote><h3 id="认识dom" tabindex="-1"><a class="header-anchor" href="#认识dom" aria-hidden="true">#</a> 认识DOM</h3><p><strong>JavaScript是一门编程语言，它的运行环境有两个，一个是浏览器，一个是node，前面我们学的JS必于ECMAScript中的语法，浏览器的JS有三部分组成：</strong></p><ul><li>ECMAScript</li><li>DOM</li><li>BOM</li></ul><blockquote><p>ECMAScript并不能和和网页进行交互，操作浏览器（网页），就需要给我们提供一个API，我们去调用API，实现操作，学习DOM和BOM就是学习浏览器给我们提供的API，所以说，DOM和BOM操作，也叫WebAPI。</p></blockquote><p><strong>深入理解DOM</strong></p><ul><li>浏览器将我们编写在HTML中的每一个元素（Element）都抽象成了一个个对象</li><li>所有这些对象都可以通过JavaScript来对其进行访问，那么我们就可以通过JavaScript来操作页面</li><li>将这个抽象过程称之为 文档对象模型（Document Object Model）</li></ul><p><strong>DOM：Docuemnt Object Model 文档对象模型</strong></p><ul><li>文档：html文档 之前的html文件就可以称一个文档</li><li>Object: 对象 一切都是对象 所有的元素都是对象</li><li>Model：模型 树模型 所有的元素，要形成一个树模型</li></ul><p><strong>整个文档被抽象到 document 对象中</strong></p><ul><li>如document.documentElement对应的是html元素</li><li>如document.body对应的是body元素</li><li>如document.head对应的是head元素</li></ul><p><img src="'+t+'" alt="01.f63fd3ed"></p><h3 id="认识window" tabindex="-1"><a class="header-anchor" href="#认识window" aria-hidden="true">#</a> 认识window</h3><p><strong>window全局对象事实上就包含了这些内容</strong></p><ul><li>JavaScript语法部分的Object、Array、Date等</li><li>DOM</li><li>BOM</li></ul><p><img src="'+a+`" alt="02.0e6380e2"></p><h3 id="document对象" tabindex="-1"><a class="header-anchor" href="#document对象" aria-hidden="true">#</a> document对象</h3><p><strong>Document节点表示的整个载入的网页，它的实例是全局的document对象</strong></p><ul><li>对DOM的所有操作都是从 document 对象开始的</li><li>它是DOM的 入口点，可以从document开始去访问任何节点元素</li></ul><p><strong>对于最顶层的html、head、body元素，我们可以直接在document对象中获取到</strong></p><ul><li>document.documentElement 得到 html元素</li><li>document.body 得到 body元素</li><li>document.head 得到 head元素</li><li>document.doctype 得到 文档声明元素</li></ul><h2 id="动态修改样式" tabindex="-1"><a class="header-anchor" href="#动态修改样式" aria-hidden="true">#</a> 动态修改样式</h2><ul><li>选择一：在CSS中编写好对应的样式，动态的添加class；</li><li>选择二：动态的修改style属性；</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 1）操作行内样式</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token string">&quot;30px&quot;</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">&quot;gold&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 2）操作class类 </span>
ele<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">&quot;active&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>因为JavaScript早期是不允许使用class这种关键字来作为对象的属性，所以DOM规范使用了className</li><li>可以对className进行赋值，它会替换整个类中的字符串</li></ul><p><strong>如果我们需要添加或者移除单个的class，那么可以使用classList属性：</strong></p><ul><li>elem.classList.add (class) ：添加一个类</li><li>elem.classList.remove(class)：添加/移除类</li><li>elem.classList.toggle(class) ：如果类不存在就添加类，存在就移除它</li><li>elem.classList.contains(class)：检查给定类，返回 true/false</li></ul><p><strong>单独修改某一个CSS属性，那么可以通过style来操作：</strong></p><ul><li>对于多词（multi-word）属性，使用驼峰式 camelCase</li><li>多个样式的写法，我们需要使用cssText属性，不推荐这种用法，因为它会替换整个字符串</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 设置</span>
boxEle<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token string">&quot;30px&quot;</span>
boxEle<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span>

<span class="token comment">// 使用cssText 了解</span>
boxEle<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> <span class="token string">&quot;background-color: pink; font-size:30px; color:red;&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于内联样式，是可以通过style.*的方式读取到的</li><li>对于style、css文件中的样式，是读取不到的</li><li>通过getComputedStyle的全局函数来实现</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>boxEle<span class="token punctuation">)</span><span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="js操作盒子模型" tabindex="-1"><a class="header-anchor" href="#js操作盒子模型" aria-hidden="true">#</a> js操作盒子模型</h2><p><img src="`+i+'" alt="09.c22ce283"></p><h3 id="client家族" tabindex="-1"><a class="header-anchor" href="#client家族" aria-hidden="true">#</a> client家族</h3><p><strong>client系列：</strong></p><ul><li>clientWidth（可视区域宽度）: 获取盒子的内容width+左右的padding</li><li>clientHeight（可视区域高度）: 获取盒子的内容height+上下的padding</li><li>clientTop:获取盒子的上边框的粗细，了解</li><li>clientLeft:获取盒子的左边框的粗细，了解</li></ul><p><strong>要获取当前页面内容的宽度（可视区域）：</strong></p><ul><li>console.log(document.body.clientWidth) // 获取一屏的宽度</li><li>console.log(document.documentElement.clientWidth)</li></ul><p><strong>要获取当前页面内容的高度（可视区域）：</strong></p><ul><li>console.log(document.body.clientHeight); // 获取内容（多屏）的高度 获取可视区域高度</li><li>console.log(document.documentElement.clientHeight); // 获取一屏的高度</li></ul><p><strong>client系列的注意点：</strong></p><ul><li>不能获取，不能设置，它们是只读的</li><li>得到的是一个数值，没有单位</li><li>得到的是一个整数，不是小数，及时测试量出来是小数，也会转化成整数</li><li>不管你的内容是否溢出，得到的是可视区的大小</li></ul><h3 id="offset家族" tabindex="-1"><a class="header-anchor" href="#offset家族" aria-hidden="true">#</a> offset家族</h3><p><strong>offset系列：</strong></p><ul><li>offsetWidth: box.offsetWidth 在clientWidth的基础上加了border 不常用</li><li>offsetHeight: box.offsetHeight 在clientHeight的基础上加了border 不常用</li><li>offsetTop: 获取一个绝对定位元素相对于参考点的上面的距离</li><li>offsetLeft: 获取一个绝对定位元素相对于参考点的左面的距离</li><li>offsetParent(***): 获取一个定位元素的参考点</li></ul><h3 id="scroll家族" tabindex="-1"><a class="header-anchor" href="#scroll家族" aria-hidden="true">#</a> scroll家族</h3><p><strong>scrollWidth:</strong></p><ul><li>在没有内容溢出(水平方向上的溢出)的情况下：scrollWidth == clientWidth</li><li>在内容溢出的情况下：scrollWidth的值约等于真实内容的宽度，此时，clientWidth的值是约等于，不同浏览器中得到的值可能不一样</li><li>overflow属性会影响scrollWidth。 只能获取值，不能设置值</li></ul><p><strong>scrollHeight:</strong></p><ul><li>在没有内容溢出的情况下：scrollHeight = clientHeight</li><li>在内容溢出的情况下：scrollHeight的值约等于真实内容的高度，不同浏览器中得到的值可能不一样</li><li>overflow属性会影响scrollHeight。</li><li>只能获取值，不能设置值</li></ul><p><strong>scrollTop:</strong></p><ul><li>获取垂直滚动条滚动的距离（获取垂直滚动条卷去的高度）</li><li>特殊：不只可以获取，也可以设置（可读可写） 重要</li></ul>',54),p=[c];function r(d,u){return n(),l("div",null,p)}const m=s(o,[["render",r],["__file","02_BOMheDOM.html.vue"]]);export{m as default};
